# 需求


- 定时任务, 每次执行定时任务时, 生成一个序号, 从001开始, 每执行一次+1; 每天重置为001
- 多线程环境安全（如并发触发定时任务）
- 边界情况（如重启、跨天、高并发）健壮处理
# 文件持久化版
- com.st.modules.serialNumber.PersistentFileSerialNumberGenerator

# 数据库持久化版

<u><span style="font-weight:bold; color:red;">方案：基于 PostgreSQL 持久化全局单例序号生成器</span></u>

---

### <u>核心设计思路</u>

* 数据表保存\_\_当天日期\_\_和\_\_序号\_\_，每次发号先取出最新序号并+1，跨天自动重置为1
* <u>保证高并发下自增唯一性</u>（采用`FOR UPDATE`悲观锁/原子SQL更新/乐观锁CAS任选）
* 支持Spring项目全局单例（可注入Service/Component）
* <u>适合分布式多实例</u>：所有服务实例都读写同一表，保证全局唯一

---

### <u>1. 数据库表设计</u>

```sql
CREATE TABLE sys_daily_serial (
    biz_type     VARCHAR(64) PRIMARY KEY,  -- 可支持多业务线，如‘VOUCHER’、‘INVOICE’，如不需要多类型可写死一行
    day          DATE NOT NULL,
    serial_no    INTEGER NOT NULL
);
-- 初始化：如只需一类，插入一行
INSERT INTO sys_daily_serial (biz_type, day, serial_no) VALUES ('VOUCHER', CURRENT_DATE, 0)
    ON CONFLICT (biz_type) DO NOTHING;
```

---

### <u>2. Java 实现（Spring Data JdbcTemplate 版）</u>

#### <u>2.1. 核心Service类</u>

```java
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.support.rowset.SqlRowSet;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;

@Component
public class DailySerialDbGenerator {

    private final JdbcTemplate jdbcTemplate;
    private static final String BIZ_TYPE = "VOUCHER"; // 可支持多业务类型扩展

    public DailySerialDbGenerator(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    /**
     * 获取当天的下一个序号，跨天自动归1，全局唯一，线程安全
     */
    @Transactional
    public String nextSerial() {
        LocalDate today = LocalDate.now();

        // 乐观锁方案：单条UPDATE + 判断受影响行数；也可用悲观锁for update，见下方补充
        int updated = jdbcTemplate.update(
            "UPDATE sys_daily_serial " +
            "SET serial_no = CASE WHEN day = ? THEN serial_no + 1 ELSE 1 END, day = ? " +
            "WHERE biz_type = ?",
            today, today, BIZ_TYPE);

        if (updated == 0) { // 首次插入
            jdbcTemplate.update(
                "INSERT INTO sys_daily_serial (biz_type, day, serial_no) VALUES (?, ?, 1) " +
                "ON CONFLICT (biz_type) DO UPDATE SET day = EXCLUDED.day, serial_no = 1",
                BIZ_TYPE, today);
        }

        // 再查一次最新序号
        SqlRowSet rs = jdbcTemplate.queryForRowSet(
                "SELECT serial_no FROM sys_daily_serial WHERE biz_type = ?", BIZ_TYPE);
        int serial = 1;
        if (rs.next()) {
            serial = rs.getInt(1);
        }
        return String.format("%03d", serial); // "001"~"999"
    }
}
```

---

#### <u>2.2. **说明与关键点**</u>

* <u>并发安全</u>：单条`UPDATE`保证原子性，数据库本身提供行级锁（推荐PostgreSQL/Oracle/MySQL等标准SQL）。
* <u>跨天自动归1</u>：判断day字段与今天是否相同，不同则重置。
* <u>主键唯一</u>：多业务线可用`biz_type`区分，如只需一种类型可忽略该字段。
* <u>分布式可用</u>：所有实例共享数据库，无需本地状态。

---

#### <u>2.3. **悲观锁for update 版本**（并发极高/序号极严格场景）</u>

```java
@Transactional
public String nextSerialWithLock() {
    LocalDate today = LocalDate.now();
    // 查询并加锁
    SqlRowSet rs = jdbcTemplate.queryForRowSet(
        "SELECT day, serial_no FROM sys_daily_serial WHERE biz_type = ? FOR UPDATE", BIZ_TYPE);
    int serial = 1;
    if (rs.next()) {
        LocalDate lastDay = rs.getDate("day").toLocalDate();
        int lastSerial = rs.getInt("serial_no");
        if (today.equals(lastDay)) {
            serial = lastSerial + 1;
        }
        // else, serial=1
        jdbcTemplate.update(
            "UPDATE sys_daily_serial SET day=?, serial_no=? WHERE biz_type=?",
            today, serial, BIZ_TYPE);
    } else {
        jdbcTemplate.update(
            "INSERT INTO sys_daily_serial (biz_type, day, serial_no) VALUES (?, ?, ?)",
            BIZ_TYPE, today, serial);
    }
    return String.format("%03d", serial);
}
```

---

### <u>3. 单元测试示例</u>

```java
@Autowired
DailySerialDbGenerator generator;

@Test
public void testSerial() {
    String sn1 = generator.nextSerial();
    String sn2 = generator.nextSerial();
    System.out.println(sn1 + " " + sn2); // 001 002
}
```

---

### <u>结论</u>

<u><span style="font-weight:bold; color:red;">此方案适合实际生产，支持高并发、分布式部署，序号重启后连续，线程/事务安全。数据库落盘，可靠性强。</span></u>

如需扩展到分布式多业务线，表结构和service方法稍作调整即可。

如果你有特殊高并发或分库分表场景，也可升级为 Redis 方案，随时可补充。
