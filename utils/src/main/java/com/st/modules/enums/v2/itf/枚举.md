# 概述

### 枚举是什么与何时使用

枚举是受限离散取值的类型系统化表示，编译期可知其所有取值，天然具备类型安全、可读性与分支穷尽性检查。适用于状态机、类别码、权限位集合、策略分发键等场景；不适用于需要运行时动态扩展的字典表

### 语法要点与成员

每个常量都是同一枚举类型的实例；可定义字段、构造器、方法；可实现接口，不可继承类；构造器隐式私有；编译器合成`values()`与`valueOf(String)`；`name()`为常量标识字符串，`ordinal()`为声明顺序索引，不建议持久化或对外暴露；`==`比较同类型枚举安全可靠；`switch`支持枚举分支

### 常量专有行为与策略化

可为每个常量提供不同实现形成“常量特定类体”，用于策略分发与状态机转移逻辑；也可在枚举上定义抽象方法由常量覆盖以表达多态

### 与集合的高效组合

```
EnumSet`基于位向量，高密度、低内存、常数时间集合操作，用于权限位与标志集合；`EnumMap`以`ordinal()`为索引的数组映射，键空间受限且极高效，优于`HashMap<Enum, V>
```

### 序列化与持久化建议

JPA建议使用`@Enumerated(EnumType.STRING)`避免`ORDINAL`漂移；MyBatis建议自定义`TypeHandler`或存`name()`或稳定`code`字段；Jackson建议以`name()`或稳定`code`出入参，避免`ordinal()`

### 最佳实践

为对外协议与持久化提供稳定`code`字段；对展示提供`label`；提供健壮的双向查找与判定工具；使用缓存避免重复扫描；避免重复`code`；避免跨类型强转；在`switch`写`default`以容错并记录告警

### 典型陷阱

不要把`ordinal()`作为持久化或协议值；不要在不同环境下改变常量顺序；不要依赖运行时添加枚举值；注意同名不同包的枚举冲突；警惕大小写与空白差异导致的解析失败

### 可复用通用工具与示例

```java
package demo.enums;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 枚举通用支持与示例
 * 概述:
 *  提供 CodeNamed 接口与基于缓存的通用查找工具 EnumUtils, 支持按 code 与常量名双向映射、判定与容错解析
 * 功能:
 *  1 统一的枚举接口 CodeNamed 提供稳定 code 与展示 label
 *  2 EnumUtils 构建并缓存 code 与 name 索引, O(1) 查找
 *  3 便捷方法 isValidCode getByCode getByName getNameByCode getCodeByName parseByCodeOrName
 * 使用示例见 DemoMain
 * 兼容:
 *  JDK8 无三方依赖 线程安全
 */
public final class EnumSupport {

    /** 对外协议稳定字段 */
    public interface CodeNamed {
        String getCode();
        String getLabel();
    }

    /** 示例枚举 订单状态 */
    public enum OrderStatus implements CodeNamed {
        NEW("NEW", "新建") {
            @Override public boolean terminal() { return false; }
        },
        PAID("PAID", "已支付") {
            @Override public boolean terminal() { return false; }
        },
        SHIPPED("SHP", "已发货") {
            @Override public boolean terminal() { return false; }
        },
        CANCELED("CNL", "已取消") {
            @Override public boolean terminal() { return true; }
        },
        DONE("DONE", "已完成") {
            @Override public boolean terminal() { return true; }
        };

        private final String code;
        private final String label;
        OrderStatus(String code, String label) { this.code = code; this.label = label; }
        @Override public String getCode() { return code; }
        @Override public String getLabel() { return label; }
        /** 示例多态行为 */
        public boolean terminal() { return false; }
    }

    /** 通用工具 */
    public static final class EnumUtils {
        private static final ConcurrentHashMap<Class<?>, Object> CODE_INDEX = new ConcurrentHashMap<>();
        private static final ConcurrentHashMap<Class<?>, Object> NAME_INDEX = new ConcurrentHashMap<>();

        private EnumUtils() {}

        /**
         * 构建或获取按 code 的只读索引
         * 说明:
         *  首次按类型扫描所有枚举值, 校验 code 唯一, 构建不可变 Map 并缓存
         * 示例:
         *  Map<String, OrderStatus> m = indexByCode(OrderStatus.class)
         */
        @SuppressWarnings("unchecked")
        public static <E extends Enum<E> & CodeNamed> Map<String, E> indexByCode(Class<E> type) {
            return (Map<String, E>) CODE_INDEX.computeIfAbsent(type, k -> {
                Map<String, E> m = new LinkedHashMap<>();
                for (E e : EnumSet.allOf(type)) {
                    String code = Objects.requireNonNull(e.getCode(), "code null in " + type.getName());
                    E old = m.put(code, e);
                    if (old != null) {
                        throw new IllegalStateException("duplicate code " + code + " in " + type.getName());
                    }
                }
                return Collections.unmodifiableMap(m);
            });
        }

        /**
         * 构建或获取按常量名的只读索引 name 不区分大小写
         * 示例:
         *  Map<String, OrderStatus> m = indexByName(OrderStatus.class)
         */
        @SuppressWarnings("unchecked")
        public static <E extends Enum<E> & CodeNamed> Map<String, E> indexByName(Class<E> type) {
            return (Map<String, E>) NAME_INDEX.computeIfAbsent(type, k -> {
                Map<String, E> m = new LinkedHashMap<>();
                for (E e : EnumSet.allOf(type)) {
                    m.put(e.name().toLowerCase(Locale.ROOT), e);
                }
                return Collections.unmodifiableMap(m);
            });
        }

        /**
         * 判定 code 是否有效
         * 返回:
         *  存在返回 true
         * 示例:
         *  boolean ok = isValidCode(OrderStatus.class, "PAID")
         */
        public static <E extends Enum<E> & CodeNamed> boolean isValidCode(Class<E> type, String code) {
            if (code == null) return false;
            return indexByCode(type).containsKey(code);
        }

        /**
         * 按 code 查找
         * 返回:
         *  Optional 枚举值
         * 示例:
         *  Optional<OrderStatus> s = getByCode(OrderStatus.class, "PAID")
         */
        public static <E extends Enum<E> & CodeNamed> Optional<E> getByCode(Class<E> type, String code) {
            if (code == null) return Optional.empty();
            return Optional.ofNullable(indexByCode(type).get(code));
        }

        /**
         * 按常量名查找 不区分大小写
         * 示例:
         *  Optional<OrderStatus> s = getByName(OrderStatus.class, "paid")
         */
        public static <E extends Enum<E> & CodeNamed> Optional<E> getByName(Class<E> type, String name) {
            if (name == null) return Optional.empty();
            return Optional.ofNullable(indexByName(type).get(name.toLowerCase(Locale.ROOT)));
        }

        /**
         * 取常量名 by code
         * 示例:
         *  String n = getNameByCode(OrderStatus.class, "PAID", "UNKNOWN")
         */
        public static <E extends Enum<E> & CodeNamed> String getNameByCode(Class<E> type, String code, String def) {
            return getByCode(type, code).map(Enum::name).orElse(def);
        }

        /**
         * 取 code by 常量名
         * 示例:
         *  String c = getCodeByName(OrderStatus.class, "PAID", "NA")
         */
        public static <E extends Enum<E> & CodeNamed> String getCodeByName(Class<E> type, String name, String def) {
            return getByName(type, name).map(CodeNamed::getCode).orElse(def);
        }

        /**
         * 以 code 或常量名解析 优先 code 兼容大小写与空白
         * 示例:
         *  OrderStatus s = parseByCodeOrName(OrderStatus.class, " paid ")
         */
        public static <E extends Enum<E> & CodeNamed> Optional<E> parseByCodeOrName(Class<E> type, String raw) {
            if (raw == null) return Optional.empty();
            String s = raw.trim();
            Optional<E> byCode = getByCode(type, s);
            if (byCode.isPresent()) return byCode;
            return getByName(type, s);
        }
    }

    /** 用法演示 */
    public static final class DemoMain {
        /**
         * 概述:
         *  展示工具方法常见用法与 EnumSet EnumMap 组合
         * 示例:
         *  运行 main 查看输出
         * 注意:
         *  真实项目请将 EnumUtils 放入公共模块
         */
        public static void main(String[] args) {
            // 判定与查找
            System.out.println(EnumUtils.isValidCode(OrderStatus.class, "PAID")); // true
            System.out.println(EnumUtils.getByName(OrderStatus.class, "done").orElse(OrderStatus.NEW));

            // 名称与 code 互取
            System.out.println(EnumUtils.getNameByCode(OrderStatus.class, "PAID", "UNKNOWN")); // PAID
            System.out.println(EnumUtils.getCodeByName(OrderStatus.class, "SHIPPED", "NA")); // SHP

            // 容错解析
            System.out.println(EnumUtils.parseByCodeOrName(OrderStatus.class, " paid ").orElse(OrderStatus.NEW));

            // EnumSet 用于权限位集合
            EnumSet<OrderStatus> terminal = EnumSet.of(OrderStatus.CANCELED, OrderStatus.DONE);
            System.out.println(terminal.contains(OrderStatus.DONE)); // true

            // EnumMap 高效映射
            EnumMap<OrderStatus, String> tips = new EnumMap<>(OrderStatus.class);
            tips.put(OrderStatus.NEW, "待提交支付");
            tips.put(OrderStatus.PAID, "待发货");
            System.out.println(tips.get(OrderStatus.PAID));

            // 策略化行为
            System.out.println(OrderStatus.DONE.terminal()); // true

            // switch 分发
            OrderStatus s = OrderStatus.PAID;
            switch (s) {
                case NEW: System.out.println("新建"); break;
                case PAID: System.out.println("已支付"); break;
                case SHIPPED: System.out.println("在途"); break;
                case CANCELED: case DONE: System.out.println("已终态"); break;
                default: System.out.println("未知状态"); // 兼容未来扩展
            }
        }
    }
}
```

### 与框架集成要点

JPA入库枚举字段优先`@Enumerated(EnumType.STRING)`或自定义转换器以存`code`；MyBatis建议自定义`TypeHandler`以`code`双向映射；Jackson建议在枚举上提供稳定`code`并在DTO层以`String code`建模或使用`@JsonValue`输出`code`与`@JsonCreator`静态工厂解析；接口协议不要使用`ordinal()`；跨系统集成时保持`code`唯一且不可变

### 你可能遇到的两类编译报错与成因

capture 通配符数组不匹配源于将`E[]`与`?[]`混用或从`values()`直接以泛型接收数组；上面工具以`EnumSet.allOf(type)`避免数组参与构建索引
 cacheOf(Class) cannot be applied多为泛型边界不一致；通用签名应为`<E extends Enum<E> & CodeNamed>`保证既有枚举特性又具备`getCode`能力

### 小结

核心是以稳定`code`对外、以`label`对内展示、以`EnumSet`与`EnumMap`高效组合、以缓存工具提供O(1)查找与判定；避免`ordinal()`对外暴露并保持常量集稳定不变即可构建健壮的枚举体系



# 枚举常见内置属性及方法

### 一眼总览

Java 的每个枚举类型都隐式继承自 `java.lang.Enum<E>` 并实现 `Comparable<E>` 与 `Serializable`；编译器为每个具体的 `enum` 额外注入 `values()` 与 `valueOf(String)` 两个静态方法；实例层面最常用的是 `name()`、`ordinal()`、`toString()`、`compareTo(E)`、`getDeclaringClass()`

### 实例方法与语义

`String name()` 返回常量源代码中的标识字符串 不可变 不可覆盖
 `int ordinal()` 返回常量在声明处的零基序号 仅用于内部排序 不建议持久化或对外协议
 `String toString()` 默认等同于 `name()` 可在具体枚举中覆盖用于友好展示
 `final int compareTo(E o)` 按 `ordinal()` 比较 实现 `Comparable<E>`
 `final boolean equals(Object o)` 同一类型同一常量恒为真 推荐直接用 `==`
 `final int hashCode()` 与 `name()` 一致性哈希
 `final Class<E> getDeclaringClass()` 返回声明该常量的枚举类型 对常量特定类体也返回枚举本身

### 编译器为每个具体枚举注入的静态方法

```
static T[] values()` 返回常量数组的拷贝 每次调用新数组 修改不影响内部缓存
 `static T valueOf(String name)` 按常量名精确解析 名称区分大小写
 异常说明
 `valueOf(String)` 与 `Enum.valueOf(Class,T)` 找不到时抛出 `IllegalArgumentException` 入参为 `null` 时抛出 `NullPointerException
```

### `Enum` 类上的通用静态方法

`static <T extends Enum<T>> T valueOf(Class<T> enumType, String name)` 适合做泛型化工具或反射场景

### 反射相关常用点

```
Class<E>.getEnumConstants()` 获取常量数组 拿不到时返回 `null`
 `Class<E>.isEnum()` 判断是否为枚举类型
 `Enum.class.getDeclaredMethods()` 可见 `Enum` 基类 API 但大多为 `final
```

### 与集合的配套类型

`EnumSet<E extends Enum<E>>` 位向量实现 适合标志位集合 与 `ordinal()` 同步基于声明顺序
 `EnumMap<K extends Enum<K>, V>` 基于数组的高效键值映射 键空间固定

### 语义与使用注意

不要把 `ordinal()` 用作数据库值或接口字段
 覆盖 `toString()` 仅用于展示 不影响 `name()` 与反序列化
 比较用 `==` 与 `switch` 更语义化 更快
 跨系统或持久化建议自带稳定 `code` 字段并自行解析

### 最小示例与常用 API 一次看全

```java
package demo;

import java.util.Arrays;

/**
 * 概述:
 *  演示枚举的内置属性与方法 使用最小例说明 name ordinal compareTo toString getDeclaringClass
 * 功能清单:
 *  1 列举 values 与迭代
 *  2 展示 name ordinal toString 比较与 switch
 *  3 展示 valueOf 与通用 Enum.valueOf
 * 使用示例:
 *  DemoEnumBuiltins.main(null)
 * 注意事项:
 *  1 valueOf 区分大小写 传入无效名称会抛 IllegalArgumentException
 *  2 values 每次返回新数组 修改不影响内部数据
 * 入参:
 *  无
 * 出参:
 *  无 控制台打印演示信息
 * 异常:
 *  无受检异常 演示 valueOf 的运行时异常时需自行 try catch
 */
public class DemoEnumBuiltins {

    public enum OrderStatus {
        NEW("新建"), PAID("已支付"), SHIPPED("已发货"), CANCELED("已取消"), DONE("已完成");
        private final String label;
        OrderStatus(String label) { this.label = label; }
        @Override public String toString() { return label; } // 仅影响展示 不影响 name
    }

    public static void main(String[] args) {
        // 1 编译器注入的静态方法 values()
        OrderStatus[] all = OrderStatus.values();
        System.out.println(Arrays.toString(all)); // 使用 toString 覆盖后的中文

        // 2 基本属性与方法 name ordinal toString
        OrderStatus s = OrderStatus.PAID;
        System.out.println(s.name());      // PAID
        System.out.println(s.ordinal());   // 1
        System.out.println(s.toString());  // 已支付
        System.out.println(s.getDeclaringClass() == OrderStatus.class); // true

        // 3 比较与等值
        System.out.println(OrderStatus.NEW == OrderStatus.valueOf("NEW")); // true
        System.out.println(OrderStatus.NEW.compareTo(OrderStatus.PAID) < 0); // true

        // 4 通用解析
        System.out.println(Enum.valueOf(OrderStatus.class, "SHIPPED")); // 常量名

        // 5 switch 分发
        switch (s) {
            case NEW: System.out.println("待支付"); break;
            case PAID: System.out.println("待发货"); break;
            case SHIPPED: System.out.println("在途"); break;
            case CANCELED: case DONE: System.out.println("已终态"); break;
            default: System.out.println("未知");
        }
    }
}
```

### 易混淆点补充

values 与 getEnumConstants 差异前者是编译器为具体枚举生成的静态方法 更直观 更安全 后者走反射 可能返回 `null`
 toString 与 name 差异`toString()` 可覆盖用于展示 `name()` 恒等于源码常量名 不可覆盖 是解析与序列化的稳定锚点
 clone 与构造器枚举常量不可被克隆或外部构造 `clone()` 在 `Enum` 中是 `final` 且 `protected` 构造器总是隐式 `private`
 序列化特殊性枚举的反序列化由 JVM 保证单例同一性 不会产生新实例 依赖 `name()` 定位常量
