# 问题

java开发中，封装工具类，移动文件：涵盖 移动一个或多个文件到另一目录，一个或多个目录到另一个目录

# 解析

## 目标

提供一个基于 NIO 的通用“移动工具类”，支持如下场景：移动单个文件到目标目录；移动多个文件到目标目录；移动单个目录到目标目录；移动多个目录到目标目录；同盘符优先原子移动，不支持原子移动或跨盘时采用“复制+校验+删除”回退；可选覆盖同名目标；返回逐项结果明细，便于上层处理失败条目

## 关键设计点

1. 统一入口方法，入参既可单个 Path 也可批量集合；目标统一为“目标目录”2. 默认把源对象“移入目标目录”，保持原名称；也提供直接指定目标完整路径的底层方法3. 同名冲突支持覆盖或失败返回；支持在目标目录下自动创建缺失的父目录4. 尝试 Files.move 带 StandardCopyOption.ATOMIC_MOVE；失败则回退到“递归拷贝+校验大小/哈希可选+删除源”5. 返回 MoveResult，包含源、目标、是否成功、失败原因
## 实战建议
1. 大文件与跨盘移动建议在 copyThenDelete 阶段追加校验逻辑（如比对文件大小或哈希）；如需哈希校验，可为 copyDirectory 的 visitFile 加入比对逻辑2. 权限与占用问题在 Windows 上更常见，失败时捕获信息记录到 MoveResult.message，便于上层告警或重试3. 与业务集成时，批量移动推荐先 dry-run 校验目标冲突、磁盘可用空间，再执行真实移动4. 如需“把目录内容直接平铺到目标目录”（而非保留目录名），可将 moveDirToDir 中 target 调整为 targetDir 而不是 resolve(sourceDir.getFileName())

## 代码（JDK8）

```java
import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;
import java.util.stream.Collectors;

public final class FileMoveUtils {
    private FileMoveUtils() {}

    public static class MoveResult {
        public final Path source;
        public final Path target;
        public final boolean success;
        public final String message;
        private MoveResult(Path source, Path target, boolean success, String message) {
            this.source = source;
            this.target = target;
            this.success = success;
            this.message = message;
        }
        public static MoveResult ok(Path s, Path t) { return new MoveResult(s, t, true, "OK"); }
        public static MoveResult fail(Path s, Path t, String msg) { return new MoveResult(s, t, false, msg); }
        @Override public String toString() {
            return (success ? "OK " : "FAIL ") + source + " -> " + target + " : " + message;
        }
    }

    public static MoveResult moveFileToDir(Path file, Path targetDir, boolean overwrite) {
        Objects.requireNonNull(file, "file");
        Objects.requireNonNull(targetDir, "targetDir");
        if (!Files.exists(file)) return MoveResult.fail(file, targetDir, "source not exists");
        if (!Files.isRegularFile(file)) return MoveResult.fail(file, targetDir, "source not a regular file");
        Path dir = ensureDirectory(targetDir);
        if (dir == null) return MoveResult.fail(file, targetDir, "cannot create targetDir");
        Path target = dir.resolve(file.getFileName());
        return movePath(file, target, overwrite);
    }

    public static List<MoveResult> moveFilesToDir(Collection<Path> files, Path targetDir, boolean overwrite) {
        if (files == null || files.isEmpty()) return Collections.emptyList();
        Path dir = ensureDirectory(targetDir);
        if (dir == null) {
            return files.stream().map(f -> MoveResult.fail(f, targetDir, "cannot create targetDir")).collect(Collectors.toList());
        }
        List<MoveResult> rs = new ArrayList<>();
        for (Path f : files) rs.add(moveFileToDir(f, dir, overwrite));
        return rs;
    }

    public static MoveResult moveDirToDir(Path sourceDir, Path targetDir, boolean overwrite) {
        Objects.requireNonNull(sourceDir, "sourceDir");
        Objects.requireNonNull(targetDir, "targetDir");
        if (!Files.exists(sourceDir)) return MoveResult.fail(sourceDir, targetDir, "source not exists");
        if (!Files.isDirectory(sourceDir)) return MoveResult.fail(sourceDir, targetDir, "source not a directory");
        Path dir = ensureDirectory(targetDir);
        if (dir == null) return MoveResult.fail(sourceDir, targetDir, "cannot create targetDir");
        Path target = dir.resolve(sourceDir.getFileName());
        return movePath(sourceDir, target, overwrite);
    }

    public static List<MoveResult> moveDirsToDir(Collection<Path> sourceDirs, Path targetDir, boolean overwrite) {
        if (sourceDirs == null || sourceDirs.isEmpty()) return Collections.emptyList();
        Path dir = ensureDirectory(targetDir);
        if (dir == null) {
            return sourceDirs.stream().map(d -> MoveResult.fail(d, targetDir, "cannot create targetDir")).collect(Collectors.toList());
        }
        List<MoveResult> rs = new ArrayList<>();
        for (Path d : sourceDirs) rs.add(moveDirToDir(d, dir, overwrite));
        return rs;
    }

    public static MoveResult movePath(Path source, Path target, boolean overwrite) {
        try {
            if (!Files.exists(source)) return MoveResult.fail(source, target, "source not exists");
            Path parent = target.getParent();
            if (parent != null) Files.createDirectories(parent);
            CopyOption[] opts = overwrite
                    ? new CopyOption[]{StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE}
                    : new CopyOption[]{StandardCopyOption.ATOMIC_MOVE};
            try {
                Files.move(source, target, opts);
                return MoveResult.ok(source, target);
            } catch (AtomicMoveNotSupportedException e) {
                // 回退到普通 move（同磁盘但不支持原子）或跨盘 copy+delete
                try {
                    if (overwrite && Files.exists(target) && Files.isDirectory(source) && !isEmptyDirectory(target)) {
                        // 目录覆盖需先清理或走替换策略，这里选择清理
                        deleteRecursively(target);
                    }
                    Files.move(source, target, overwrite ? StandardCopyOption.REPLACE_EXISTING : new CopyOption[]{});
                    return MoveResult.ok(source, target);
                } catch (IOException ex) {
                    // 再次回退到 copy+delete
                    return copyThenDelete(source, target, overwrite);
                }
            } catch (FileAlreadyExistsException e) {
                return MoveResult.fail(source, target, "target exists and overwrite=false");
            } catch (IOException e) {
                // 直接进入回退
                return copyThenDelete(source, target, overwrite);
            }
        } catch (IOException e) {
            return MoveResult.fail(source, target, "io error: " + e.getMessage());
        }
    }

    private static MoveResult copyThenDelete(Path source, Path target, boolean overwrite) {
        try {
            if (Files.isDirectory(source)) {
                if (Files.exists(target)) {
                    if (!overwrite) return MoveResult.fail(source, target, "target exists and overwrite=false");
                    deleteRecursively(target);
                }
                copyDirectory(source, target, overwrite);
            } else {
                if (Files.exists(target) && !overwrite) return MoveResult.fail(source, target, "target exists and overwrite=false");
                Files.createDirectories(target.getParent());
                if (overwrite) {
                    Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);
                } else {
                    Files.copy(source, target, StandardCopyOption.COPY_ATTRIBUTES);
                }
            }
            // 删除源
            deleteRecursively(source);
            return MoveResult.ok(source, target);
        } catch (IOException e) {
            return MoveResult.fail(source, target, "copy-then-delete failed: " + e.getMessage());
        }
    }

    private static Path ensureDirectory(Path dir) {
        try {
            Files.createDirectories(dir);
            return dir;
        } catch (IOException e) {
            return null;
        }
    }

    private static void copyDirectory(Path sourceDir, Path targetDir, boolean overwrite) throws IOException {
        Files.walkFileTree(sourceDir, new SimpleFileVisitor<Path>() {
            @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                Path rel = sourceDir.relativize(dir);
                Path t = targetDir.resolve(rel);
                Files.createDirectories(t);
                return FileVisitResult.CONTINUE;
            }
            @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Path rel = sourceDir.relativize(file);
                Path t = targetDir.resolve(rel);
                if (Files.exists(t) && !overwrite) return FileVisitResult.TERMINATE;
                if (overwrite) {
                    Files.copy(file, t, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);
                } else {
                    Files.copy(file, t, StandardCopyOption.COPY_ATTRIBUTES);
                }
                return FileVisitResult.CONTINUE;
            }
        });
    }

    private static void deleteRecursively(Path path) throws IOException {
        if (!Files.exists(path)) return;
        Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
            @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Files.deleteIfExists(file);
                return FileVisitResult.CONTINUE;
            }
            @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                Files.deleteIfExists(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    }

    private static boolean isEmptyDirectory(Path dir) throws IOException {
        try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir)) {
            return !ds.iterator().hasNext();
        }
    }
}
```

## 代码/带注释版

````java
### 注释版源码（保持实现不变，仅新增注释与示例）

```java
import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.*;
import java.util.stream.Collectors;

/**
 * 文件/目录移动工具类（JDK8，基于 NIO）
 * 功能清单：
 * 1) 移动单个文件到目标目录（保留原文件名）：{@link #moveFileToDir(Path, Path, boolean)}
 * 2) 批量移动多个文件到目标目录：{@link #moveFilesToDir(Collection, Path, boolean)}
 * 3) 移动单个目录到目标目录（保留目录名）：{@link #moveDirToDir(Path, Path, boolean)}
 * 4) 批量移动多个目录到目标目录：{@link #moveDirsToDir(Collection, Path, boolean)}
 * 5) 通用底层移动（文件或目录到“完整目标路径”）：{@link #movePath(Path, Path, boolean)}
 * 行为与策略：
 * - 优先尝试原子移动（StandardCopyOption.ATOMIC_MOVE，通常要求同一分区/设备且文件系统支持）
 * - 原子移动不支持或失败时，回退到普通 Files.move；仍失败则执行“复制→（可选覆盖）→删除源”
 * - 覆盖策略由 overwrite 控制；目录覆盖在必要时会先清理既有目标目录
 * - 所有批量方法逐项返回结果，不因单项失败中断其余项处理
 * 使用示例：
 * <pre>{@code
 * Path to = Paths.get("/data/target");
 * // 1) 移动单个文件到目录
 * FileMoveUtils.MoveResult r1 = FileMoveUtils.moveFileToDir(Paths.get("/data/a.log"), to, true);
 * System.out.println(r1);
 * // 2) 批量移动多个文件到目录
 * List<FileMoveUtils.MoveResult> r2 = FileMoveUtils.moveFilesToDir(
 *     Arrays.asList(Paths.get("/data/b.txt"), Paths.get("/data/c.txt")), to, false);
 * r2.forEach(System.out::println);
 * // 3) 移动单个目录到目录
 * FileMoveUtils.MoveResult r3 = FileMoveUtils.moveDirToDir(Paths.get("/data/dir1"), to, true);
 * System.out.println(r3);
 * // 4) 批量移动多个目录到目录
 * List<FileMoveUtils.MoveResult> r4 = FileMoveUtils.moveDirsToDir(
 *     Arrays.asList(Paths.get("/data/dir2"), Paths.get("/data/dir3")), to, true);
 * r4.forEach(System.out::println);
 * }</pre>
 */
public final class FileMoveUtils {
    private FileMoveUtils() {}

    /**
     * 单项移动结果
     * 语义：
     * - source：源路径
     * - target：目标路径（最终落位路径）
     * - success：是否成功
     * - message：失败原因或“OK”
     */
    public static class MoveResult {
        public final Path source;
        public final Path target;
        public final boolean success;
        public final String message;
        private MoveResult(Path source, Path target, boolean success, String message) {
            this.source = source;
            this.target = target;
            this.success = success;
            this.message = message;
        }
        /** 构造成功结果快捷方法 */
        public static MoveResult ok(Path s, Path t) { return new MoveResult(s, t, true, "OK"); }
        /** 构造失败结果快捷方法（附带失败原因） */
        public static MoveResult fail(Path s, Path t, String msg) { return new MoveResult(s, t, false, msg); }
        @Override public String toString() {
            return (success ? "OK " : "FAIL ") + source + " -> " + target + " : " + message;
        }
    }

    /**
     * 将“单个文件”移动到“目标目录”（保留原文件名）
     * 例如：/var/log/a.log -> /archive/a.log
     * @param file 源文件路径（必须存在且为常规文件）
     * @param targetDir 目标目录（不存在将自动创建）
     * @param overwrite 若目标存在同名文件，是否覆盖
     * @return 单项移动结果
     */
    public static MoveResult moveFileToDir(Path file, Path targetDir, boolean overwrite) {
        Objects.requireNonNull(file, "file");
        Objects.requireNonNull(targetDir, "targetDir");
        if (!Files.exists(file)) return MoveResult.fail(file, targetDir, "source not exists");
        if (!Files.isRegularFile(file)) return MoveResult.fail(file, targetDir, "source not a regular file");
        Path dir = ensureDirectory(targetDir);
        if (dir == null) return MoveResult.fail(file, targetDir, "cannot create targetDir");
        Path target = dir.resolve(file.getFileName()); // 目标路径为“目标目录/源文件名”
        return movePath(file, target, overwrite);
    }

    /**
     * 将“多个文件”批量移动到“同一目标目录”
     * 逐项处理并返回结果集合，空集合入参返回空集合
     * @param files 源文件集合（依次校验存在性与文件类型）
     * @param targetDir 目标目录（不存在将自动创建）
     * @param overwrite 覆盖策略
     * @return 结果列表；每个文件一个结果
     */
    public static List<MoveResult> moveFilesToDir(Collection<Path> files, Path targetDir, boolean overwrite) {
        if (files == null || files.isEmpty()) return Collections.emptyList();
        Path dir = ensureDirectory(targetDir);
        if (dir == null) {
            return files.stream().map(f -> MoveResult.fail(f, targetDir, "cannot create targetDir")).collect(Collectors.toList());
        }
        List<MoveResult> rs = new ArrayList<>();
        for (Path f : files) rs.add(moveFileToDir(f, dir, overwrite));
        return rs;
    }

    /**
     * 将“单个目录”移动到“目标目录”（保留目录名）
     * 例如：/data/dir1 -> /backup/dir1
     * @param sourceDir 源目录（必须存在且为目录）
     * @param targetDir 目标目录（不存在将自动创建）
     * @param overwrite 目标存在同名目录时是否允许覆盖（必要时会清理目标）
     * @return 单项移动结果
     */
    public static MoveResult moveDirToDir(Path sourceDir, Path targetDir, boolean overwrite) {
        Objects.requireNonNull(sourceDir, "sourceDir");
        Objects.requireNonNull(targetDir, "targetDir");
        if (!Files.exists(sourceDir)) return MoveResult.fail(sourceDir, targetDir, "source not exists");
        if (!Files.isDirectory(sourceDir)) return MoveResult.fail(sourceDir, targetDir, "source not a directory");
        Path dir = ensureDirectory(targetDir);
        if (dir == null) return MoveResult.fail(sourceDir, targetDir, "cannot create targetDir");
        Path target = dir.resolve(sourceDir.getFileName()); // 目标路径为“目标目录/源目录名”
        return movePath(sourceDir, target, overwrite);
    }

    /**
     * 将“多个目录”批量移动到“同一目标目录”（保留各自目录名）
     * 逐项处理并返回结果集合，空集合入参返回空集合
     * @param sourceDirs 源目录集合
     * @param targetDir 目标目录（不存在将自动创建）
     * @param overwrite 覆盖策略
     * @return 结果列表；每个目录一个结果
     */
    public static List<MoveResult> moveDirsToDir(Collection<Path> sourceDirs, Path targetDir, boolean overwrite) {
        if (sourceDirs == null || sourceDirs.isEmpty()) return Collections.emptyList();
        Path dir = ensureDirectory(targetDir);
        if (dir == null) {
            return sourceDirs.stream().map(d -> MoveResult.fail(d, targetDir, "cannot create targetDir")).collect(Collectors.toList());
        }
        List<MoveResult> rs = new ArrayList<>();
        for (Path d : sourceDirs) rs.add(moveDirToDir(d, dir, overwrite));
        return rs;
    }

    /**
     * 底层通用移动：将“文件或目录”移动到“完整的目标路径”
     * 策略：
     * 1) 优先尝试原子移动（ATOMIC_MOVE），成功则直接返回
     * 2) 原子移动不支持或失败时，尝试普通 Files.move（可带 REPLACE_EXISTING）
     * 3) 仍失败时，回退到“复制→（可选覆盖）→删除源”的保守策略
     * 注意：
     * - 跨分区/设备通常不支持原子移动，可能直接进入回退
     * - overwrite=false 且目标已存在时，返回失败
     * @param source 源路径（文件或目录，必须存在）
     * @param target 目标完整路径（包含最终文件名或目录名）
     * @param overwrite 是否允许覆盖已存在目标
     * @return 单项移动结果
     */
    public static MoveResult movePath(Path source, Path target, boolean overwrite) {
        try {
            if (!Files.exists(source)) return MoveResult.fail(source, target, "source not exists");
            Path parent = target.getParent();
            if (parent != null) Files.createDirectories(parent); // 确保目标父目录存在
            CopyOption[] opts = overwrite
                    ? new CopyOption[]{StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE}
                    : new CopyOption[]{StandardCopyOption.ATOMIC_MOVE};
            try {
                // 首选：原子移动（需要文件系统与同设备支持）
                Files.move(source, target, opts);
                return MoveResult.ok(source, target);
            } catch (AtomicMoveNotSupportedException e) {
                // 不支持原子移动：尝试普通 move（同磁盘但不支持原子）或跨盘情况
                try {
                    if (overwrite && Files.exists(target) && Files.isDirectory(source) && !isEmptyDirectory(target)) {
                        // 目录覆盖且目标非空：先清理目标，确保覆盖语义一致
                        deleteRecursively(target);
                    }
                    Files.move(source, target, overwrite ? StandardCopyOption.REPLACE_EXISTING : new CopyOption[]{});
                    return MoveResult.ok(source, target);
                } catch (IOException ex) {
                    // 普通 move 仍失败：回退到“复制+删除”
                    return copyThenDelete(source, target, overwrite);
                }
            } catch (FileAlreadyExistsException e) {
                // 目标存在且不允许覆盖
                return MoveResult.fail(source, target, "target exists and overwrite=false");
            } catch (IOException e) {
                // 其他 IO 异常：直接走回退
                return copyThenDelete(source, target, overwrite);
            }
        } catch (IOException e) {
            return MoveResult.fail(source, target, "io error: " + e.getMessage());
        }
    }

    /**
     * 回退策略：先复制到目标，再删除源
     * 目录：构建目标目录树并逐文件复制；文件：直接复制
     * 覆盖语义遵循 overwrite；若不允许覆盖且目标已存在，则失败
     */
    private static MoveResult copyThenDelete(Path source, Path target, boolean overwrite) {
        try {
            if (Files.isDirectory(source)) {
                if (Files.exists(target)) {
                    if (!overwrite) return MoveResult.fail(source, target, "target exists and overwrite=false");
                    deleteRecursively(target); // 允许覆盖目录时先清理目标
                }
                copyDirectory(source, target, overwrite);
            } else {
                if (Files.exists(target) && !overwrite) return MoveResult.fail(source, target, "target exists and overwrite=false");
                Files.createDirectories(target.getParent()); // 文件复制确保父目录存在
                if (overwrite) {
                    Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);
                } else {
                    Files.copy(source, target, StandardCopyOption.COPY_ATTRIBUTES);
                }
            }
            // 复制成功后删除源（目录将被递归删除）
            deleteRecursively(source);
            return MoveResult.ok(source, target);
        } catch (IOException e) {
            return MoveResult.fail(source, target, "copy-then-delete failed: " + e.getMessage());
        }
    }

    /** 确保目录存在；创建失败返回 null */
    private static Path ensureDirectory(Path dir) {
        try {
            Files.createDirectories(dir);
            return dir;
        } catch (IOException e) {
            return null;
        }
    }

    /**
     * 递归复制目录内容到目标目录
     * 注意：当 overwrite=false 且遇到已存在文件时，会 TERMINATE 终止遍历，可能导致部分文件已复制
     */
    private static void copyDirectory(Path sourceDir, Path targetDir, boolean overwrite) throws IOException {
        Files.walkFileTree(sourceDir, new SimpleFileVisitor<Path>() {
            @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                Path rel = sourceDir.relativize(dir);
                Path t = targetDir.resolve(rel);
                Files.createDirectories(t); // 按相对路径构建目标目录树
                return FileVisitResult.CONTINUE;
            }
            @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Path rel = sourceDir.relativize(file);
                Path t = targetDir.resolve(rel);
                if (Files.exists(t) && !overwrite) return FileVisitResult.TERMINATE; // 不允许覆盖则终止遍历
                if (overwrite) {
                    Files.copy(file, t, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES);
                } else {
                    Files.copy(file, t, StandardCopyOption.COPY_ATTRIBUTES);
                }
                return FileVisitResult.CONTINUE;
            }
        });
    }

    /** 递归删除文件或目录（安全地逐文件/逐目录删除） */
    private static void deleteRecursively(Path path) throws IOException {
        if (!Files.exists(path)) return;
        Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
            @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                Files.deleteIfExists(file);
                return FileVisitResult.CONTINUE;
            }
            @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                Files.deleteIfExists(dir);
                return FileVisitResult.CONTINUE;
            }
        });
    }

    /** 判断目录是否为空（无任何子项） */
    private static boolean isEmptyDirectory(Path dir) throws IOException {
        try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir)) {
            return !ds.iterator().hasNext();
        }
    }
}
```

````



## 使用示例

```java
import java.nio.file.*;
import java.util.Arrays;
import java.util.List;

public class Demo {
    public static void main(String[] args) {
        Path to = Paths.get("/data/target");

        FileMoveUtils.MoveResult r1 = FileMoveUtils.moveFileToDir(Paths.get("/data/a.log"), to, true);
        System.out.println(r1);

        List<FileMoveUtils.MoveResult> r2 = FileMoveUtils.moveFilesToDir(
                Arrays.asList(Paths.get("/data/b.txt"), Paths.get("/data/c.txt")),
                to, false);
        r2.forEach(System.out::println);

        FileMoveUtils.MoveResult r3 = FileMoveUtils.moveDirToDir(Paths.get("/data/dir1"), to, true);
        System.out.println(r3);

        List<FileMoveUtils.MoveResult> r4 = FileMoveUtils.moveDirsToDir(
                Arrays.asList(Paths.get("/data/dir2"), Paths.get("/data/dir3")),
                to, true);
        r4.forEach(System.out::println);
    }
}
```

# 新增功能: 重命名

## 新功能说明

提供直接指定目标完整路径的底层方法

## “直接指定目标完整路径”的含义

指绕过“把源放入某个目标目录”这层封装，直接给出最终目标路径（含文件名或目录名），由底层完成移动；适用于“重命名移动”“按规则改名后落位”等场景

## 设计要点

1. 公开以完整目标路径为参数的方法，文件与目录各一组2. 内部统一委托给底层通用方法 movePath(source,target,overwrite)3. 行为与目录版保持一致：同盘尝试原子移动；不支持时回退为复制+校验（可扩展）+删除

## 代码位置与实现

下面在原有 FileMoveUtils 中新增两组方法；底层仍使用现有 movePath

```java
public final class FileMoveUtils {
    // ...前文已有代码省略

    /**
     * 直接移动“单个文件”到指定的目标“完整路径”（可同时完成重命名）
     * 例如: /logs/a.log -> /archive/2025/08/a-1.log
     * @param sourceFile 源文件路径（必须是常规文件）
     * @param targetFile 目标完整路径（含文件名）
     * @param overwrite  目标存在时是否覆盖
     */
    public static MoveResult moveFile(Path sourceFile, Path targetFile, boolean overwrite) {
        Objects.requireNonNull(sourceFile, "sourceFile");
        Objects.requireNonNull(targetFile, "targetFile");
        if (!Files.exists(sourceFile)) return MoveResult.fail(sourceFile, targetFile, "source not exists");
        if (!Files.isRegularFile(sourceFile)) return MoveResult.fail(sourceFile, targetFile, "source not a regular file");
        return movePath(sourceFile, targetFile, overwrite);
    }

    /**
     * 批量移动“多个文件”到各自指定的目标完整路径（可分别重命名）
     * 要求 sources.size == targets.size；一一对应
     */
    public static List<MoveResult> moveFiles(List<Path> sources, List<Path> targets, boolean overwrite) {
        if (sources == null || targets == null || sources.size() != targets.size()) {
            throw new IllegalArgumentException("sources and targets must be non-null and same size");
        }
        List<MoveResult> rs = new ArrayList<>(sources.size());
        for (int i = 0; i < sources.size(); i++) {
            rs.add(moveFile(sources.get(i), targets.get(i), overwrite));
        }
        return rs;
    }

    /**
     * 直接移动“目录”到指定的目标“完整目录路径”（可同时完成重命名）
     * 例如: /data/input -> /data/archive/input-20250816
     */
    public static MoveResult moveDirectory(Path sourceDir, Path targetDir, boolean overwrite) {
        Objects.requireNonNull(sourceDir, "sourceDir");
        Objects.requireNonNull(targetDir, "targetDir");
        if (!Files.exists(sourceDir)) return MoveResult.fail(sourceDir, targetDir, "source not exists");
        if (!Files.isDirectory(sourceDir)) return MoveResult.fail(sourceDir, targetDir, "source not a directory");
        return movePath(sourceDir, targetDir, overwrite);
    }

    /**
     * 批量移动“多个目录”到各自指定的目标完整目录路径
     */
    public static List<MoveResult> moveDirectories(List<Path> sources, List<Path> targets, boolean overwrite) {
        if (sources == null || targets == null || sources.size() != targets.size()) {
            throw new IllegalArgumentException("sources and targets must be non-null and same size");
        }
        List<MoveResult> rs = new ArrayList<>(sources.size());
        for (int i = 0; i < sources.size(); i++) {
            rs.add(moveDirectory(sources.get(i), targets.get(i), overwrite));
        }
        return rs;
    }

    // 已有的通用底层方法，负责原子移动与回退策略
    public static MoveResult movePath(Path source, Path target, boolean overwrite) {
        // ...前文已有实现
        return null; // 占位：请保留你现有实现
    }
}
```

## 用法示例

```java
// 文件重命名并移动
FileMoveUtils.moveFile(
    Paths.get("/logs/app.log"),
    Paths.get("/archive/2025/08/app-20250816.log"),
    true);

// 批量文件一一对应改名移动
List<FileMoveUtils.MoveResult> rs1 = FileMoveUtils.moveFiles(
    Arrays.asList(Paths.get("/a/1.txt"), Paths.get("/a/2.txt")),
    Arrays.asList(Paths.get("/b/x1.txt"), Paths.get("/b/x2.txt")),
    false);

// 目录重命名并移动
FileMoveUtils.moveDirectory(
    Paths.get("/data/input"),
    Paths.get("/data/archive/input-20250816"),
    true);

// 批量目录一一对应移动
List<FileMoveUtils.MoveResult> rs2 = FileMoveUtils.moveDirectories(
    Arrays.asList(Paths.get("/d/dirA"), Paths.get("/d/dirB")),
    Arrays.asList(Paths.get("/e/A-2025"), Paths.get("/e/B-2025")),
    true);
```



